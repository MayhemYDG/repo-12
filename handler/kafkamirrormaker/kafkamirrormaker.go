// Code generated by Aiven. DO NOT EDIT.

package kafkamirrormaker

import (
	"context"
	"encoding/json"
	"fmt"
)

type Handler interface {
	// CreateReplicationFlow create a replication flow
	// ServiceKafkaMirrorMakerCreateReplicationFlow POST /project/{project}/service/{service_name}/mirrormaker/replication-flows
	// https://api.aiven.io/doc/#tag/Service:_Kafka_MirrorMaker/operation/ServiceKafkaMirrorMakerCreateReplicationFlow
	CreateReplicationFlow(ctx context.Context, project string, serviceName string, in *CreateReplicationFlowIn) error

	// DeleteReplicationFlow delete a replication flow
	// ServiceKafkaMirrorMakerDeleteReplicationFlow DELETE /project/{project}/service/{service_name}/mirrormaker/replication-flows/{source_cluster}/{target_cluster}
	// https://api.aiven.io/doc/#tag/Service:_Kafka_MirrorMaker/operation/ServiceKafkaMirrorMakerDeleteReplicationFlow
	DeleteReplicationFlow(ctx context.Context, project string, serviceName string, sourceCluster string, targetCluster string) error

	// GetReplicationFlow get a replication flow
	// ServiceKafkaMirrorMakerGetReplicationFlow GET /project/{project}/service/{service_name}/mirrormaker/replication-flows/{source_cluster}/{target_cluster}
	// https://api.aiven.io/doc/#tag/Service:_Kafka_MirrorMaker/operation/ServiceKafkaMirrorMakerGetReplicationFlow
	GetReplicationFlow(ctx context.Context, project string, serviceName string, sourceCluster string, targetCluster string) (*ReplicationFlow, error)

	// GetReplicationFlows get replication flows
	// ServiceKafkaMirrorMakerGetReplicationFlows GET /project/{project}/service/{service_name}/mirrormaker/replication-flows
	// https://api.aiven.io/doc/#tag/Service:_Kafka_MirrorMaker/operation/ServiceKafkaMirrorMakerGetReplicationFlows
	GetReplicationFlows(ctx context.Context, project string, serviceName string) ([]ReplicationFlow, error)

	// PatchReplicationFlow update a replication flow
	// ServiceKafkaMirrorMakerPatchReplicationFlow PUT /project/{project}/service/{service_name}/mirrormaker/replication-flows/{source_cluster}/{target_cluster}
	// https://api.aiven.io/doc/#tag/Service:_Kafka_MirrorMaker/operation/ServiceKafkaMirrorMakerPatchReplicationFlow
	PatchReplicationFlow(ctx context.Context, project string, serviceName string, sourceCluster string, targetCluster string, in *PatchReplicationFlowIn) (*ReplicationFlow, error)
}

func NewHandler(doer doer) Handler {
	return &handler{doer}
}

type doer interface {
	Do(ctx context.Context, operationID, method, path string, v any) ([]byte, error)
}

type handler struct {
	doer doer
}

func (h *handler) CreateReplicationFlow(ctx context.Context, project string, serviceName string, in *CreateReplicationFlowIn) error {
	path := fmt.Sprintf("/project/%s/service/%s/mirrormaker/replication-flows", project, serviceName)
	_, err := h.doer.Do(ctx, "ServiceKafkaMirrorMakerCreateReplicationFlow", "POST", path, in)
	return err
}
func (h *handler) DeleteReplicationFlow(ctx context.Context, project string, serviceName string, sourceCluster string, targetCluster string) error {
	path := fmt.Sprintf("/project/%s/service/%s/mirrormaker/replication-flows/%s/%s", project, serviceName, sourceCluster, targetCluster)
	_, err := h.doer.Do(ctx, "ServiceKafkaMirrorMakerDeleteReplicationFlow", "DELETE", path, nil)
	return err
}
func (h *handler) GetReplicationFlow(ctx context.Context, project string, serviceName string, sourceCluster string, targetCluster string) (*ReplicationFlow, error) {
	path := fmt.Sprintf("/project/%s/service/%s/mirrormaker/replication-flows/%s/%s", project, serviceName, sourceCluster, targetCluster)
	b, err := h.doer.Do(ctx, "ServiceKafkaMirrorMakerGetReplicationFlow", "GET", path, nil)
	out := new(GetReplicationFlowOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.ReplicationFlow, nil
}
func (h *handler) GetReplicationFlows(ctx context.Context, project string, serviceName string) ([]ReplicationFlow, error) {
	path := fmt.Sprintf("/project/%s/service/%s/mirrormaker/replication-flows", project, serviceName)
	b, err := h.doer.Do(ctx, "ServiceKafkaMirrorMakerGetReplicationFlows", "GET", path, nil)
	out := new(GetReplicationFlowsOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.ReplicationFlows, nil
}
func (h *handler) PatchReplicationFlow(ctx context.Context, project string, serviceName string, sourceCluster string, targetCluster string, in *PatchReplicationFlowIn) (*ReplicationFlow, error) {
	path := fmt.Sprintf("/project/%s/service/%s/mirrormaker/replication-flows/%s/%s", project, serviceName, sourceCluster, targetCluster)
	b, err := h.doer.Do(ctx, "ServiceKafkaMirrorMakerPatchReplicationFlow", "PUT", path, in)
	out := new(PatchReplicationFlowOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.ReplicationFlow, nil
}

type CreateReplicationFlowIn struct {
	ConfigPropertiesExclude         string                       `json:"config_properties_exclude,omitempty"`
	EmitHeartbeatsEnabled           *bool                        `json:"emit_heartbeats_enabled,omitempty"`
	Enabled                         bool                         `json:"enabled"`
	OffsetSyncsTopicLocation        OffsetSyncsTopicLocationType `json:"offset_syncs_topic_location,omitempty"`
	ReplicationPolicyClass          ReplicationPolicyClassType   `json:"replication_policy_class,omitempty"`
	SourceCluster                   string                       `json:"source_cluster"`
	SyncGroupOffsetsEnabled         *bool                        `json:"sync_group_offsets_enabled,omitempty"`
	SyncGroupOffsetsIntervalSeconds *int                         `json:"sync_group_offsets_interval_seconds,omitempty"`
	TargetCluster                   string                       `json:"target_cluster"`
	Topics                          []string                     `json:"topics,omitempty"`
	TopicsBlacklist                 []string                     `json:"topics.blacklist,omitempty"`
}
type GetReplicationFlowOut struct {
	ReplicationFlow *ReplicationFlow `json:"replication_flow"`
}
type GetReplicationFlowsOut struct {
	ReplicationFlows []ReplicationFlow `json:"replication_flows"`
}
type OffsetSyncsTopicLocationType string

const (
	OffsetSyncsTopicLocationTypeSource OffsetSyncsTopicLocationType = "source"
	OffsetSyncsTopicLocationTypeTarget OffsetSyncsTopicLocationType = "target"
)

type PatchReplicationFlowIn struct {
	ConfigPropertiesExclude         string                       `json:"config_properties_exclude,omitempty"`
	EmitHeartbeatsEnabled           *bool                        `json:"emit_heartbeats_enabled,omitempty"`
	Enabled                         *bool                        `json:"enabled,omitempty"`
	OffsetSyncsTopicLocation        OffsetSyncsTopicLocationType `json:"offset_syncs_topic_location,omitempty"`
	ReplicationPolicyClass          ReplicationPolicyClassType   `json:"replication_policy_class,omitempty"`
	SyncGroupOffsetsEnabled         *bool                        `json:"sync_group_offsets_enabled,omitempty"`
	SyncGroupOffsetsIntervalSeconds *int                         `json:"sync_group_offsets_interval_seconds,omitempty"`
	Topics                          []string                     `json:"topics,omitempty"`
	TopicsBlacklist                 []string                     `json:"topics.blacklist,omitempty"`
}
type PatchReplicationFlowOut struct {
	ReplicationFlow *ReplicationFlow `json:"replication_flow"`
}
type ReplicationFlow struct {
	ConfigPropertiesExclude         string                       `json:"config_properties_exclude,omitempty"`
	EmitHeartbeatsEnabled           *bool                        `json:"emit_heartbeats_enabled,omitempty"`
	Enabled                         bool                         `json:"enabled"`
	OffsetSyncsTopicLocation        OffsetSyncsTopicLocationType `json:"offset_syncs_topic_location,omitempty"`
	ReplicationPolicyClass          ReplicationPolicyClassType   `json:"replication_policy_class,omitempty"`
	SourceCluster                   string                       `json:"source_cluster"`
	SyncGroupOffsetsEnabled         *bool                        `json:"sync_group_offsets_enabled,omitempty"`
	SyncGroupOffsetsIntervalSeconds *int                         `json:"sync_group_offsets_interval_seconds,omitempty"`
	TargetCluster                   string                       `json:"target_cluster"`
	Topics                          []string                     `json:"topics,omitempty"`
	TopicsBlacklist                 []string                     `json:"topics.blacklist,omitempty"`
}
type ReplicationPolicyClassType string

const (
	ReplicationPolicyClassTypeOrgApacheKafkaConnectMirrorDefaultReplicationPolicy  ReplicationPolicyClassType = "org.apache.kafka.connect.mirror.DefaultReplicationPolicy"
	ReplicationPolicyClassTypeOrgApacheKafkaConnectMirrorIdentityReplicationPolicy ReplicationPolicyClassType = "org.apache.kafka.connect.mirror.IdentityReplicationPolicy"
)
