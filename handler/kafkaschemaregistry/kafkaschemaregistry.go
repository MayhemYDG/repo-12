// Code generated by Aiven. DO NOT EDIT.

package kafkaschemaregistry

import (
	"context"
	"encoding/json"
	"fmt"
)

type Handler interface {
	// ServiceSchemaRegistryAclAdd add a Schema Registry ACL entry
	// POST /project/{project}/service/{service_name}/kafka/schema-registry/acl
	// https://api.aiven.io/doc/#tag/Service:_Kafka/operation/ServiceSchemaRegistryAclAdd
	ServiceSchemaRegistryAclAdd(ctx context.Context, project string, serviceName string, in *ServiceSchemaRegistryAclAddIn) ([]Acl, error)

	// ServiceSchemaRegistryAclDelete delete a Schema Registry ACL entry
	// DELETE /project/{project}/service/{service_name}/kafka/schema-registry/acl/{schema_registry_acl_id}
	// https://api.aiven.io/doc/#tag/Service:_Kafka/operation/ServiceSchemaRegistryAclDelete
	ServiceSchemaRegistryAclDelete(ctx context.Context, project string, serviceName string, schemaRegistryAclId string) ([]Acl, error)

	// ServiceSchemaRegistryAclList list Schema Registry ACL entries
	// GET /project/{project}/service/{service_name}/kafka/schema-registry/acl
	// https://api.aiven.io/doc/#tag/Service:_Kafka/operation/ServiceSchemaRegistryAclList
	ServiceSchemaRegistryAclList(ctx context.Context, project string, serviceName string) ([]Acl, error)

	// ServiceSchemaRegistryCompatibility check compatibility of schema in Schema Registry
	// POST /project/{project}/service/{service_name}/kafka/schema/compatibility/subjects/{subject_name}/versions/{version_id:latest|\d+}
	// https://api.aiven.io/doc/#tag/Service:_Kafka/operation/ServiceSchemaRegistryCompatibility
	ServiceSchemaRegistryCompatibility(ctx context.Context, project string, serviceName string, subjectName string, versionId int, in *ServiceSchemaRegistryCompatibilityIn) (bool, error)

	// ServiceSchemaRegistryGlobalConfigGet get global configuration for Schema Registry
	// GET /project/{project}/service/{service_name}/kafka/schema/config
	// https://api.aiven.io/doc/#tag/Service:_Kafka/operation/ServiceSchemaRegistryGlobalConfigGet
	ServiceSchemaRegistryGlobalConfigGet(ctx context.Context, project string, serviceName string) (CompatibilityLevelType, error)

	// ServiceSchemaRegistryGlobalConfigPut edit global configuration for Schema Registry
	// PUT /project/{project}/service/{service_name}/kafka/schema/config
	// https://api.aiven.io/doc/#tag/Service:_Kafka/operation/ServiceSchemaRegistryGlobalConfigPut
	ServiceSchemaRegistryGlobalConfigPut(ctx context.Context, project string, serviceName string, in *ServiceSchemaRegistryGlobalConfigPutIn) (CompatibilityLevelType, error)

	// ServiceSchemaRegistrySchemaGet get schema in Schema Registry
	// GET /project/{project}/service/{service_name}/kafka/schema/schemas/ids/{schema_id}
	// https://api.aiven.io/doc/#tag/Service:_Kafka/operation/ServiceSchemaRegistrySchemaGet
	ServiceSchemaRegistrySchemaGet(ctx context.Context, project string, serviceName string, schemaId string) error

	// ServiceSchemaRegistrySubjectConfigGet get configuration for Schema Registry subject
	// GET /project/{project}/service/{service_name}/kafka/schema/config/{subject_name}
	// https://api.aiven.io/doc/#tag/Service:_Kafka/operation/ServiceSchemaRegistrySubjectConfigGet
	ServiceSchemaRegistrySubjectConfigGet(ctx context.Context, project string, serviceName string, subjectName string) (CompatibilityLevelType, error)

	// ServiceSchemaRegistrySubjectConfigPut edit configuration for Schema Registry subject
	// PUT /project/{project}/service/{service_name}/kafka/schema/config/{subject_name}
	// https://api.aiven.io/doc/#tag/Service:_Kafka/operation/ServiceSchemaRegistrySubjectConfigPut
	ServiceSchemaRegistrySubjectConfigPut(ctx context.Context, project string, serviceName string, subjectName string, in *ServiceSchemaRegistrySubjectConfigPutIn) (CompatibilityLevelType, error)

	// ServiceSchemaRegistrySubjectDelete delete Schema Registry subject
	// DELETE /project/{project}/service/{service_name}/kafka/schema/subjects/{subject_name}
	// https://api.aiven.io/doc/#tag/Service:_Kafka/operation/ServiceSchemaRegistrySubjectDelete
	ServiceSchemaRegistrySubjectDelete(ctx context.Context, project string, serviceName string, subjectName string) error

	// ServiceSchemaRegistrySubjectVersionDelete delete Schema Registry subject version
	// DELETE /project/{project}/service/{service_name}/kafka/schema/subjects/{subject_name}/versions/{version_id:latest|\d+}
	// https://api.aiven.io/doc/#tag/Service:_Kafka/operation/ServiceSchemaRegistrySubjectVersionDelete
	ServiceSchemaRegistrySubjectVersionDelete(ctx context.Context, project string, serviceName string, subjectName string, versionId int) error

	// ServiceSchemaRegistrySubjectVersionGet get Schema Registry Subject version
	// GET /project/{project}/service/{service_name}/kafka/schema/subjects/{subject_name}/versions/{version_id:latest|\d+}
	// https://api.aiven.io/doc/#tag/Service:_Kafka/operation/ServiceSchemaRegistrySubjectVersionGet
	ServiceSchemaRegistrySubjectVersionGet(ctx context.Context, project string, serviceName string, subjectName string, versionId int) error

	// ServiceSchemaRegistrySubjectVersionPost register a new Schema in Schema Registry
	// POST /project/{project}/service/{service_name}/kafka/schema/subjects/{subject_name}/versions
	// https://api.aiven.io/doc/#tag/Service:_Kafka/operation/ServiceSchemaRegistrySubjectVersionPost
	ServiceSchemaRegistrySubjectVersionPost(ctx context.Context, project string, serviceName string, subjectName string, in *ServiceSchemaRegistrySubjectVersionPostIn) (int, error)

	// ServiceSchemaRegistrySubjectVersionsGet get Schema Registry subject versions
	// GET /project/{project}/service/{service_name}/kafka/schema/subjects/{subject_name}/versions
	// https://api.aiven.io/doc/#tag/Service:_Kafka/operation/ServiceSchemaRegistrySubjectVersionsGet
	ServiceSchemaRegistrySubjectVersionsGet(ctx context.Context, project string, serviceName string, subjectName string) ([]int, error)

	// ServiceSchemaRegistrySubjects lists Schema Registry subjects
	// GET /project/{project}/service/{service_name}/kafka/schema/subjects
	// https://api.aiven.io/doc/#tag/Service:_Kafka/operation/ServiceSchemaRegistrySubjects
	ServiceSchemaRegistrySubjects(ctx context.Context, project string, serviceName string) ([]string, error)
}

func NewHandler(doer doer) KafkaSchemaRegistryHandler {
	return KafkaSchemaRegistryHandler{doer}
}

type doer interface {
	Do(ctx context.Context, operationID, method, path string, v any) ([]byte, error)
}

type KafkaSchemaRegistryHandler struct {
	doer doer
}

func (h *KafkaSchemaRegistryHandler) ServiceSchemaRegistryAclAdd(ctx context.Context, project string, serviceName string, in *ServiceSchemaRegistryAclAddIn) ([]Acl, error) {
	path := fmt.Sprintf("/project/%s/service/%s/kafka/schema-registry/acl", project, serviceName)
	b, err := h.doer.Do(ctx, "ServiceSchemaRegistryAclAdd", "POST", path, in)
	out := new(ServiceSchemaRegistryAclAddOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.Acl, nil
}
func (h *KafkaSchemaRegistryHandler) ServiceSchemaRegistryAclDelete(ctx context.Context, project string, serviceName string, schemaRegistryAclId string) ([]Acl, error) {
	path := fmt.Sprintf("/project/%s/service/%s/kafka/schema-registry/acl/%s", project, serviceName, schemaRegistryAclId)
	b, err := h.doer.Do(ctx, "ServiceSchemaRegistryAclDelete", "DELETE", path, nil)
	out := new(ServiceSchemaRegistryAclDeleteOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.Acl, nil
}
func (h *KafkaSchemaRegistryHandler) ServiceSchemaRegistryAclList(ctx context.Context, project string, serviceName string) ([]Acl, error) {
	path := fmt.Sprintf("/project/%s/service/%s/kafka/schema-registry/acl", project, serviceName)
	b, err := h.doer.Do(ctx, "ServiceSchemaRegistryAclList", "GET", path, nil)
	out := new(ServiceSchemaRegistryAclListOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.Acl, nil
}
func (h *KafkaSchemaRegistryHandler) ServiceSchemaRegistryCompatibility(ctx context.Context, project string, serviceName string, subjectName string, versionId int, in *ServiceSchemaRegistryCompatibilityIn) (bool, error) {
	path := fmt.Sprintf("/project/%s/service/%s/kafka/schema/compatibility/subjects/%s/versions/%d", project, serviceName, subjectName, versionId)
	b, err := h.doer.Do(ctx, "ServiceSchemaRegistryCompatibility", "POST", path, in)
	out := new(ServiceSchemaRegistryCompatibilityOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return false, err
	}
	return out.IsCompatible, nil
}
func (h *KafkaSchemaRegistryHandler) ServiceSchemaRegistryGlobalConfigGet(ctx context.Context, project string, serviceName string) (CompatibilityLevelType, error) {
	path := fmt.Sprintf("/project/%s/service/%s/kafka/schema/config", project, serviceName)
	b, err := h.doer.Do(ctx, "ServiceSchemaRegistryGlobalConfigGet", "GET", path, nil)
	out := new(ServiceSchemaRegistryGlobalConfigGetOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return "", err
	}
	return out.CompatibilityLevel, nil
}
func (h *KafkaSchemaRegistryHandler) ServiceSchemaRegistryGlobalConfigPut(ctx context.Context, project string, serviceName string, in *ServiceSchemaRegistryGlobalConfigPutIn) (CompatibilityLevelType, error) {
	path := fmt.Sprintf("/project/%s/service/%s/kafka/schema/config", project, serviceName)
	b, err := h.doer.Do(ctx, "ServiceSchemaRegistryGlobalConfigPut", "PUT", path, in)
	out := new(ServiceSchemaRegistryGlobalConfigPutOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return "", err
	}
	return out.Compatibility, nil
}
func (h *KafkaSchemaRegistryHandler) ServiceSchemaRegistrySchemaGet(ctx context.Context, project string, serviceName string, schemaId string) error {
	path := fmt.Sprintf("/project/%s/service/%s/kafka/schema/schemas/ids/%s", project, serviceName, schemaId)
	_, err := h.doer.Do(ctx, "ServiceSchemaRegistrySchemaGet", "GET", path, nil)
	return err
}
func (h *KafkaSchemaRegistryHandler) ServiceSchemaRegistrySubjectConfigGet(ctx context.Context, project string, serviceName string, subjectName string) (CompatibilityLevelType, error) {
	path := fmt.Sprintf("/project/%s/service/%s/kafka/schema/config/%s", project, serviceName, subjectName)
	b, err := h.doer.Do(ctx, "ServiceSchemaRegistrySubjectConfigGet", "GET", path, nil)
	out := new(ServiceSchemaRegistrySubjectConfigGetOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return "", err
	}
	return out.CompatibilityLevel, nil
}
func (h *KafkaSchemaRegistryHandler) ServiceSchemaRegistrySubjectConfigPut(ctx context.Context, project string, serviceName string, subjectName string, in *ServiceSchemaRegistrySubjectConfigPutIn) (CompatibilityLevelType, error) {
	path := fmt.Sprintf("/project/%s/service/%s/kafka/schema/config/%s", project, serviceName, subjectName)
	b, err := h.doer.Do(ctx, "ServiceSchemaRegistrySubjectConfigPut", "PUT", path, in)
	out := new(ServiceSchemaRegistrySubjectConfigPutOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return "", err
	}
	return out.Compatibility, nil
}
func (h *KafkaSchemaRegistryHandler) ServiceSchemaRegistrySubjectDelete(ctx context.Context, project string, serviceName string, subjectName string) error {
	path := fmt.Sprintf("/project/%s/service/%s/kafka/schema/subjects/%s", project, serviceName, subjectName)
	_, err := h.doer.Do(ctx, "ServiceSchemaRegistrySubjectDelete", "DELETE", path, nil)
	return err
}
func (h *KafkaSchemaRegistryHandler) ServiceSchemaRegistrySubjectVersionDelete(ctx context.Context, project string, serviceName string, subjectName string, versionId int) error {
	path := fmt.Sprintf("/project/%s/service/%s/kafka/schema/subjects/%s/versions/%d", project, serviceName, subjectName, versionId)
	_, err := h.doer.Do(ctx, "ServiceSchemaRegistrySubjectVersionDelete", "DELETE", path, nil)
	return err
}
func (h *KafkaSchemaRegistryHandler) ServiceSchemaRegistrySubjectVersionGet(ctx context.Context, project string, serviceName string, subjectName string, versionId int) error {
	path := fmt.Sprintf("/project/%s/service/%s/kafka/schema/subjects/%s/versions/%d", project, serviceName, subjectName, versionId)
	_, err := h.doer.Do(ctx, "ServiceSchemaRegistrySubjectVersionGet", "GET", path, nil)
	return err
}
func (h *KafkaSchemaRegistryHandler) ServiceSchemaRegistrySubjectVersionPost(ctx context.Context, project string, serviceName string, subjectName string, in *ServiceSchemaRegistrySubjectVersionPostIn) (int, error) {
	path := fmt.Sprintf("/project/%s/service/%s/kafka/schema/subjects/%s/versions", project, serviceName, subjectName)
	b, err := h.doer.Do(ctx, "ServiceSchemaRegistrySubjectVersionPost", "POST", path, in)
	out := new(ServiceSchemaRegistrySubjectVersionPostOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return 0, err
	}
	return out.Id, nil
}
func (h *KafkaSchemaRegistryHandler) ServiceSchemaRegistrySubjectVersionsGet(ctx context.Context, project string, serviceName string, subjectName string) ([]int, error) {
	path := fmt.Sprintf("/project/%s/service/%s/kafka/schema/subjects/%s/versions", project, serviceName, subjectName)
	b, err := h.doer.Do(ctx, "ServiceSchemaRegistrySubjectVersionsGet", "GET", path, nil)
	out := new(ServiceSchemaRegistrySubjectVersionsGetOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.Versions, nil
}
func (h *KafkaSchemaRegistryHandler) ServiceSchemaRegistrySubjects(ctx context.Context, project string, serviceName string) ([]string, error) {
	path := fmt.Sprintf("/project/%s/service/%s/kafka/schema/subjects", project, serviceName)
	b, err := h.doer.Do(ctx, "ServiceSchemaRegistrySubjects", "GET", path, nil)
	out := new(ServiceSchemaRegistrySubjectsOut)
	err = json.Unmarshal(b, out)
	if err != nil {
		return nil, err
	}
	return out.Subjects, nil
}

type Acl struct {
	Id         string         `json:"id,omitempty"`
	Permission PermissionType `json:"permission"`
	Resource   string         `json:"resource"`
	Username   string         `json:"username"`
}
type CompatibilityLevelType string

const (
	CompatibilityLevelTypeBackward           CompatibilityLevelType = "BACKWARD"
	CompatibilityLevelTypeBackwardTransitive CompatibilityLevelType = "BACKWARD_TRANSITIVE"
	CompatibilityLevelTypeForward            CompatibilityLevelType = "FORWARD"
	CompatibilityLevelTypeForwardTransitive  CompatibilityLevelType = "FORWARD_TRANSITIVE"
	CompatibilityLevelTypeFull               CompatibilityLevelType = "FULL"
	CompatibilityLevelTypeFullTransitive     CompatibilityLevelType = "FULL_TRANSITIVE"
	CompatibilityLevelTypeNone               CompatibilityLevelType = "NONE"
)

type PermissionType string

const (
	PermissionTypeSchemaRegistryRead  PermissionType = "schema_registry_read"
	PermissionTypeSchemaRegistryWrite PermissionType = "schema_registry_write"
)

func PermissionTypeChoices() []string {
	return []string{"schema_registry_read", "schema_registry_write"}
}

type Reference struct {
	Name    string `json:"name"`
	Subject string `json:"subject"`
	Version int    `json:"version"`
}
type SchemaType string

const (
	SchemaTypeAvro     SchemaType = "AVRO"
	SchemaTypeJson     SchemaType = "JSON"
	SchemaTypeProtobuf SchemaType = "PROTOBUF"
)

func SchemaTypeChoices() []string {
	return []string{"AVRO", "JSON", "PROTOBUF"}
}

type ServiceSchemaRegistryAclAddIn struct {
	Permission PermissionType `json:"permission"`
	Resource   string         `json:"resource"`
	Username   string         `json:"username"`
}
type ServiceSchemaRegistryAclAddOut struct {
	Acl []Acl `json:"acl"`
}
type ServiceSchemaRegistryAclDeleteOut struct {
	Acl []Acl `json:"acl"`
}
type ServiceSchemaRegistryAclListOut struct {
	Acl []Acl `json:"acl"`
}
type ServiceSchemaRegistryCompatibilityIn struct {
	Schema     string     `json:"schema"`
	SchemaType SchemaType `json:"schemaType,omitempty"`
}
type ServiceSchemaRegistryCompatibilityOut struct {
	IsCompatible bool `json:"is_compatible"`
}
type ServiceSchemaRegistryGlobalConfigGetOut struct {
	CompatibilityLevel CompatibilityLevelType `json:"compatibilityLevel"`
}
type ServiceSchemaRegistryGlobalConfigPutIn struct {
	Compatibility CompatibilityLevelType `json:"compatibility"`
}
type ServiceSchemaRegistryGlobalConfigPutOut struct {
	Compatibility CompatibilityLevelType `json:"compatibility"`
}
type ServiceSchemaRegistrySubjectConfigGetOut struct {
	CompatibilityLevel CompatibilityLevelType `json:"compatibilityLevel"`
}
type ServiceSchemaRegistrySubjectConfigPutIn struct {
	Compatibility CompatibilityLevelType `json:"compatibility"`
}
type ServiceSchemaRegistrySubjectConfigPutOut struct {
	Compatibility CompatibilityLevelType `json:"compatibility"`
}
type ServiceSchemaRegistrySubjectVersionPostIn struct {
	References []Reference `json:"references"`
	Schema     string      `json:"schema"`
	SchemaType SchemaType  `json:"schemaType,omitempty"`
}
type ServiceSchemaRegistrySubjectVersionPostOut struct {
	Id int `json:"id"`
}
type ServiceSchemaRegistrySubjectVersionsGetOut struct {
	Versions []int `json:"versions"`
}
type ServiceSchemaRegistrySubjectsOut struct {
	Subjects []string `json:"subjects"`
}
